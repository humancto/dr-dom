/**
 * URLhaus Malware Detection
 * Checks all loaded resources against real-time malware database
 * Updates every 5 minutes from abuse.ch
 */

class MalwareDetector {
  constructor() {
    this.threats = [];
    this.checkedUrls = new Set();
    this.malwareDatabase = new Set();
    
    // Initialize with known malware indicators
    this.suspiciousPatterns = [
      /eval\(unescape/i,
      /document\.write\(unescape/i,
      /\.exe$/i,
      /\.scr$/i,
      /\.vbs$/i,
      /\.cmd$/i,
      /\.bat$/i,
      /\.ps1$/i,
      /coinhive\.com/i,
      /cryptoloot\.com/i,
      /coin-hive\.com/i,
      /jsecoin\.com/i,
      /cryptonight/i,
      /minergate/i
    ];
    
    // Load URLhaus data
    this.loadMalwareList();
  }
  
  async loadMalwareList() {
    try {
      // Request URLhaus data from background script to avoid CORS
      chrome.runtime.sendMessage(
        { type: 'URLHAUS_UPDATE', url: 'https://urlhaus.abuse.ch/downloads/csv_recent/' },
        (response) => {
          if (chrome.runtime.lastError) {
            console.warn('[Malware Detector] Extension error:', chrome.runtime.lastError);
            return;
          }
          
          if (response && response.success && response.data) {
            // Parse CSV (skip header)
            const lines = response.data.split('\n').slice(1);
            lines.forEach(line => {
              if (line.trim()) {
                const parts = line.split(',');
                if (parts[2]) { // URL is in 3rd column
                  const url = parts[2].replace(/"/g, '');
                  try {
                    const urlObj = new URL(url);
                    this.malwareDatabase.add(urlObj.hostname);
                    this.malwareDatabase.add(url);
                  } catch (e) {
                    // Invalid URL
                  }
                }
              }
            });
            
            console.log(`[Malware Detector] Loaded ${this.malwareDatabase.size} malicious URLs`);
          } else {
            console.warn('[Malware Detector] Could not load URLhaus data from background');
          }
        }
      );
    } catch (error) {
      console.warn('[Malware Detector] Could not load URLhaus data:', error);
      // Fall back to pattern-based detection
    }
  }
  
  async checkUrl(url) {
    if (!url || this.checkedUrls.has(url)) return null;
    this.checkedUrls.add(url);
    
    // Check against malware database
    try {
      const urlObj = new URL(url);
      const hostname = urlObj.hostname;
      
      // Check exact URL match
      if (this.malwareDatabase.has(url)) {
        return {
          threat: true,
          type: 'malware',
          source: 'URLhaus',
          severity: 'critical',
          url: url,
          message: '🚨 MALWARE: This URL is known to serve malicious content!',
          details: 'Listed in URLhaus malware database'
        };
      }
      
      // Check hostname
      if (this.malwareDatabase.has(hostname)) {
        return {
          threat: true,
          type: 'malicious-domain',
          source: 'URLhaus',
          severity: 'high',
          url: url,
          message: '⚠️ DANGEROUS: This domain hosts malware!',
          details: 'Domain is known for distributing malicious content'
        };
      }
      
      // Check suspicious patterns
      for (const pattern of this.suspiciousPatterns) {
        if (pattern.test(url)) {
          return {
            threat: true,
            type: 'suspicious',
            source: 'pattern',
            severity: 'medium',
            url: url,
            message: '⚡ SUSPICIOUS: URL matches malware pattern',
            details: `Pattern: ${pattern.source}`
          };
        }
      }
      
      // Check for cryptominers
      if (this.isCryptominer(url)) {
        return {
          threat: true,
          type: 'cryptominer',
          source: 'pattern',
          severity: 'medium',
          url: url,
          message: '⛏️ CRYPTOMINER: This site is mining cryptocurrency using your CPU!',
          details: 'Cryptomining script detected'
        };
      }
      
      // Check for phishing indicators
      if (this.isPhishing(url, hostname)) {
        return {
          threat: true,
          type: 'phishing',
          source: 'heuristic',
          severity: 'high',
          url: url,
          message: '🎣 PHISHING: This might be a phishing attempt!',
          details: 'URL mimics legitimate service'
        };
      }
      
    } catch (e) {
      // Invalid URL
    }
    
    return null;
  }
  
  isCryptominer(url) {
    const minerDomains = [
      'coinhive.com', 'coin-hive.com', 'jsecoin.com',
      'cryptoloot.com', 'crypto-loot.com', 'webmine.cz',
      'miner.pr0gramm.com', 'minemytraffic.com',
      'projectpoi.com', 'papoto.com', 'minero.pw',
      'webmine.pro', 'poolmining.online', 'webminepool.com'
    ];
    
    const urlLower = url.toLowerCase();
    return minerDomains.some(domain => urlLower.includes(domain));
  }
  
  isPhishing(url, hostname) {
    // Common phishing patterns
    const legitimateDomains = [
      'google.com', 'facebook.com', 'amazon.com', 'apple.com',
      'microsoft.com', 'paypal.com', 'ebay.com', 'netflix.com',
      'bankofamerica.com', 'chase.com', 'wellsfargo.com'
    ];
    
    // Check for typosquatting
    for (const legit of legitimateDomains) {
      const legitName = legit.split('.')[0];
      
      // Check for common misspellings
      if (hostname.includes(legitName) && !hostname.includes(legit)) {
        // Possible typosquatting
        if (hostname.includes(legitName + '-') || 
            hostname.includes(legitName + '.') ||
            hostname.includes(legitName.replace('o', '0')) ||
            hostname.includes(legitName.replace('i', '1'))) {
          return true;
        }
      }
      
      // Check for homograph attacks (using similar looking characters)
      const homographs = {
        'o': '0',
        'i': '1',
        'l': '1',
        'e': '3',
        'a': '@',
        's': '5'
      };
      
      let variant = legitName;
      for (const [original, replacement] of Object.entries(homographs)) {
        variant = variant.replace(original, replacement);
        if (hostname.includes(variant)) {
          return true;
        }
      }
    }
    
    // Check for suspicious URL patterns
    if (url.includes('secure-') || url.includes('account-update') ||
        url.includes('verify-') || url.includes('suspended')) {
      return true;
    }
    
    return false;
  }
  
  async scanPage() {
    const threats = [];
    
    // Get all requests from storage
    const domain = window.location.hostname;
    const storageKey = `drDOM_${domain}`;
    
    chrome.storage.local.get(storageKey, async (result) => {
      const data = result[storageKey];
      if (!data || !data.requests) return;
      
      // Check each request
      for (const request of data.requests) {
        const threat = await this.checkUrl(request.url);
        if (threat) {
          threats.push(threat);
        }
      }
      
      // Check current page URL
      const pageThreat = await this.checkUrl(window.location.href);
      if (pageThreat) {
        threats.unshift(pageThreat); // Add to beginning
      }
      
      // Store threats
      if (threats.length > 0) {
        chrome.storage.local.set({
          [`${storageKey}_threats`]: {
            threats: threats,
            timestamp: Date.now(),
            summary: this.generateThreatSummary(threats)
          }
        });
        
        console.warn(`[Malware Detector] Found ${threats.length} threats!`, threats);
        
        // Alert user if critical threat
        const critical = threats.find(t => t.severity === 'critical');
        if (critical) {
          this.alertUser(critical);
        }
      }
    });
    
    return threats;
  }
  
  generateThreatSummary(threats) {
    const summary = {
      total: threats.length,
      critical: threats.filter(t => t.severity === 'critical').length,
      high: threats.filter(t => t.severity === 'high').length,
      medium: threats.filter(t => t.severity === 'medium').length,
      types: {}
    };
    
    threats.forEach(threat => {
      summary.types[threat.type] = (summary.types[threat.type] || 0) + 1;
    });
    
    return summary;
  }
  
  alertUser(threat) {
    // Create alert banner
    const banner = document.createElement('div');
    banner.id = 'drdom-threat-alert';
    banner.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: linear-gradient(135deg, #f44336, #d32f2f);
      color: white;
      padding: 15px;
      z-index: 999999;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      box-shadow: 0 2px 10px rgba(0,0,0,0.3);
      animation: slideDown 0.3s ease;
    `;
    
    banner.innerHTML = `
      <div style="max-width: 1200px; margin: 0 auto; display: flex; align-items: center; justify-content: space-between;">
        <div>
          <div style="font-size: 18px; font-weight: bold; margin-bottom: 5px;">
            ${threat.message}
          </div>
          <div style="font-size: 14px; opacity: 0.9;">
            ${threat.details} - Detected by Dr. DOM Security Scanner
          </div>
        </div>
        <button onclick="this.parentElement.parentElement.remove()" 
                style="background: white; color: #f44336; border: none; padding: 8px 16px; 
                       border-radius: 4px; cursor: pointer; font-weight: bold;">
          Dismiss
        </button>
      </div>
    `;
    
    document.body.appendChild(banner);
    
    // Auto-remove after 10 seconds
    setTimeout(() => {
      if (document.getElementById('drdom-threat-alert')) {
        document.getElementById('drdom-threat-alert').remove();
      }
    }, 10000);
  }
}

// Initialize malware detector
const malwareDetector = new MalwareDetector();

// Scan page after load
setTimeout(() => {
  malwareDetector.scanPage();
}, 2000);

// Monitor new requests
const originalFetch = window.fetch;
window.fetch = async function(...args) {
  const url = args[0]?.toString();
  if (url) {
    const threat = await malwareDetector.checkUrl(url);
    if (threat && threat.severity === 'critical') {
      console.error('[BLOCKED] Malicious request blocked:', threat);
      throw new Error('Request blocked: Malware detected');
    }
  }
  return originalFetch.apply(this, args);
};

console.log('[Dr. DOM] Malware detector initialized');